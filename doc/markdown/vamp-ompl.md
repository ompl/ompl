# VAMP-OMPL Integration Demo {#vamp-ompl}

A high-performance motion planning system that integrates VAMP's SIMD-accelerated collision detection with OMPL's comprehensive planner library.

## Quick Start

### Prerequisites

- pybullet (for visualization): `pip install pybullet`

### Basic Usage

```bash
# Single planning run
./demo_Vamp                              # Default configuration
./demo_Vamp panda_demo.yaml              # YAML configuration

# Benchmarking
./demo_Vamp panda_benchmark.yaml --benchmark
./demo_Vamp --robot panda               # Quick benchmark

# Visualization
./demo_Vamp panda_demo.yaml --visualize
```

### Command Line Options

- `--benchmark`: Enable benchmarking mode (generates OMPL-compliant .log files)
- `--visualize`: Enable 3D visualization output
- `--robot <name>`: Quick benchmark for specific robot (panda, ur5, fetch)
- `--planar-arm`: Run 2DOF planar arm demo (can combine with --benchmark or --visualize)
- `--list-robots`: List all registered robots
- `--help`: Show complete usage information

## Key Features

- **SIMD-Accelerated Performance**: 8x faster collision checking via vectorization
- **Extensible OMPL Planners**: Built-in support for RRT-Connect, BIT*, PRM with easy registration for additional planners
- **Multiple Robot Types**: Built-in support for Panda, UR5, Fetch robots
- **Custom Robot Support**: Extensible robot registration system
- **YAML Configuration**: Flexible scene and planner configuration
- **OMPL-Compliant Benchmarking**: Standard .log files compatible with Planner Arena
- **3D Visualization**: Interactive PyBullet-based visualization
- **Pointcloud Support**: .xyz, .ply, .pcd obstacle formats

## Configuration Examples

### YAML Configuration

```yaml
robot:
  name: "panda"
  description: "Franka Emika Panda arm"

planner:
  name: "RRT-Connect"
  planning_time: 5.0

start_config: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
goal_config: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]

obstacles:
  - type: "sphere"
    position: [0.5, 0.5, 0.5]
    radius: 0.1
  - type: pointcloud
    pointcloud_file: "environment.xyz"
    point_radius: 0.0025
```

### Benchmarking Workflow

```bash
# 1. Run benchmark
./demo_Vamp panda_benchmark.yaml --benchmark

# 2. Generate database (from OMPL root directory)
python3 scripts/ompl_benchmark_statistics.py vamp_benchmark_*.log -d results.db

# 3. Visualize at http://plannerarena.org (upload results.db)
```

## Custom Robot Development

**Quick Example:**

```cpp
// 1. Define robot (see examples/CustomRobotExample.h)
namespace vamp::robots {
    struct MyRobot {
        static constexpr auto name = "my_robot";
        static constexpr auto dimension = 6;
        // ... implement required interface
    };
}

// 2. Register robot
REGISTER_VAMP_ROBOT(vamp::robots::MyRobot, "my_robot");

// 3. Use in YAML or command line
./demo_Vamp --robot my_robot --benchmark
```

### Prerequisites for Custom Robots

**⚠️ Important**: Custom robots for VAMP require specialized code generation tools:

#### 1. **Cricket Compiler** (Required)
VAMP uses a tracing compilation step to generate optimized SIMD code for collision checking. You **must** use the [cricket compiler](https://github.com/CoMMALab/cricket) to generate the vectorized forward kinematics and collision checking methods (`fkcc` function).

- **Repository**: https://github.com/CoMMALab/cricket
- **Purpose**: Generates SIMD-optimized collision detection code from robot URDF
- **Output**: Vectorized `fkcc` method required by VAMP robot interface

#### 2. **Foam Tool** (Required for Spherization)
You need a spherical decomposition of your robot's collision geometry. This can be generated automatically using the [foam tool](https://github.com/CoMMALab/foam).

- **Repository**: https://github.com/CoMMALab/foam  
- **Purpose**: Generates spherical approximations of robot collision geometry from URDF
- **Output**: Sphere positions and radii for collision detection

**⚠️ Warning**: Some tuning of the robot spherization may be necessary. Start with a finer approximation and work up from there.

### Development Workflow

1. **Prepare Robot Model**: Ensure you have a valid URDF with collision geometry
2. **Generate Spherization**: Use `foam` to create spherical collision approximation
3. **Generate SIMD Code**: Use `cricket` compiler to generate vectorized collision checking
4. **Implement Robot Interface**: Create robot struct with required VAMP interface
5. **Register Robot**: Use `REGISTER_VAMP_ROBOT` macro for integration

### Robot Interface Requirements

Your custom robot must implement the VAMP robot interface including:

```cpp
struct CustomRobot {
    // Required compile-time constants
    static constexpr auto name = "custom_robot";
    static constexpr auto dimension = 7;        // Joint count
    static constexpr auto n_spheres = 10;       // Collision spheres
    static constexpr auto resolution = 64;      // Motion validation resolution
    
    // Joint limits (generated by cricket)
    static constexpr std::array<float, dimension> s_a = {/* lower limits */};
    static constexpr std::array<float, dimension> s_m = {/* ranges */};
    
    // Vectorized forward kinematics + collision checking (generated by cricket)
    template<std::size_t rake>
    inline static auto fkcc(
        const vamp::collision::Environment<vamp::FloatVector<rake>>& environment,
        const vamp::ConfigurationBlock<rake>& q) noexcept -> bool;
    
    // Configuration scaling methods
    inline static void scale_configuration(Configuration& q) noexcept;
    inline static void descale_configuration(Configuration& q) noexcept;
};
```

**Note**: The critical `fkcc` method must be generated using the cricket compiler - manual implementation is not recommended due to the complexity of SIMD vectorization.

## Documentation

- **[Architecture Overview](vamp-ompl-architecture.md)**: System design and performance architecture
- **[API Reference](vamp-ompl-API-reference.md)**: Complete API documentation

## Performance Notes

- 8x collision detection speedup through SIMD vectorization
- Zero-allocation hot paths via function-local static buffers
- Cache-optimized memory access with Structure-of-Arrays layout

**Dependencies:**

- Robot complexity (joint count, collision spheres)
- Environment density (obstacle count and distribution)  
- Hardware SIMD capabilities (AVX2 recommended)
