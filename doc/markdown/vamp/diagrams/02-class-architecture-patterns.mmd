---
title: "VAMP Class Architecture - Design Patterns & Relationships"
---
classDiagram
    %% OMPL Foundation Interfaces
    class OMPLStateValidityChecker {
        <<interface>>
        +isValid(state) bool*
        +clearance(state) double
    }
    
    class OMPLMotionValidator {
        <<interface>>
        +checkMotion(start, end) bool*
        +checkMotion(start, end, lastValid) bool*
    }
    
    class OMPLPlanner {
        <<abstract>>
        +solve(terminationCondition) PlannerStatus*
        +setProblemDefinition(pdef)*
        +setup()*
        +clear()*
        #si_ SpaceInformationPtr
        #pdef_ ProblemDefinitionPtr
    }
    
    class OMPLSpaceInformation {
        +setStateValidityChecker(checker)
        +setMotionValidator(validator)
        +setup()
        +isValid(state) bool
        +checkMotion(s1, s2) bool
        -stateSpace_ StateSpacePtr
        -stateValidityChecker_ StateValidityCheckerPtr
        -motionValidator_ MotionValidatorPtr
    }
    
    class OMPLProblemDefinition {
        +setStartAndGoalStates(start, goal)
        +setOptimizationObjective(obj)
        +addStartState(state)
        +getSolutionPath() PathPtr
        +hasSolution() bool
        -si_ SpaceInformationPtr
        -startStates_ vector~State~
        -goal_ GoalPtr
        -solutions_ vector~SolutionPtr~
    }
    
    %% VAMP Core Integration Classes
    class VampStateValidator~Robot~ {
        <<SIMD-accelerated>>
        -vectorizedEnvironment VectorizedEnvironment
        +isValid(state) bool
        -ompl_to_vamp(state) Configuration
        +VampStateValidator(si, venv)
    }
    
    class VampMotionValidator~Robot~ {
        <<SIMD-accelerated>>
        -vectorizedEnvironment VectorizedEnvironment
        +checkMotion(start, end) bool
        +checkMotion(start, end, lastValid) bool
        -ompl_to_vamp(state) Configuration
        +VampMotionValidator(si, venv)
        +motionSamplingResolution: size_t = Robot::resolution
    }
    
    class VampOMPLPlanner~Robot~ {
        <<Facade Pattern>>
        -robotConfiguration unique_ptr~RobotConfig~Robot~~
        -environmentFactory unique_ptr~EnvironmentFactory~
        -planningContext OMPLPlanningContext~Robot~
        -vectorizedEnvironment VectorizedEnvironment
        -isInitialized bool
        +VampOMPLPlanner(robotConfig, envFactory)
        +initialize()
        +plan(config) PlanningResult
        +writeOptimizedSolutionPath() string
        +getSpaceInformation() SpaceInformationPtr
        +printConfiguration()
        +isInitialized() bool
    }
    
    class OMPLPlanningContext~Robot~ {
        <<Adapter Pattern>>
        -spaceInformation SpaceInformationPtr
        -problemDefinition ProblemDefinitionPtr
        +setupStateSpace(robotConfig, venv)
        +setProblem(start, goal)
        +plan(config) PlanningResult
        -createPlannerByName(name) PlannerPtr
        +registerPlanner(name, factory) static
    }
    
    class PlannerRegistry {
        <<Singleton Registry>>
        -plannerAllocators map~string, PlannerAllocatorFunction~
        -mutex mutex
        +getInstance() PlannerRegistry& static
        +registerPlanner(name, allocator)
        +createPlanner(name, si, params) PlannerPtr
        +isPlannerRegistered(name) bool
        +getRegisteredPlanners() vector~string~
        +getAvailablePlannerNames() string
        +getPlannerCount() size_t
        -registerBuiltInPlanners()
        -applyParameters(planner, params) static
    }
    
    %% Configuration System Hierarchy
    class RobotConfig~Robot~ {
        <<interface>>
        +getJointLimits() vector~pair~double,double~~*
        +getStartConfigurationArray() array~float,dimension~*
        +getGoalConfigurationArray() array~float,dimension~*
        +getRobotName() string*
        +dimension: size_t = Robot::dimension
    }
    
    class RobotConfiguration~Robot~ {
        -startConfig vector~float~
        -goalConfig vector~float~
        -robotName string
        +RobotConfiguration(name, start, goal)
        +getJointLimits() vector~pair~double,double~~
        +getStartConfigurationArray() array~float,dimension~
        +getGoalConfigurationArray() array~float,dimension~
        +getRobotName() string
        -vectorToArray(vec) array~float,dimension~
        -validateConfigurationSize()
        -validateJointLimits()
    }
    
    class EnvironmentFactory {
        <<interface>>
        +createEnvironment() Environment~float~*
        +getEnvironmentName() string*
        +getDescription() string*
    }
    
    class ConfigurableEnvironmentFactory {
        -obstacleConfigurations vector~ObstacleConfig~
        -environmentName string
        +ConfigurableEnvironmentFactory(name, obstacles)
        +createEnvironment() Environment~float~
        +getEnvironmentName() string
        +getDescription() string
        +addObstacle(obstacle)
        +setObstacles(obstacles)
    }
    
    %% Registry System
    class RobotRegistry {
        <<Singleton>>
        -handlers map~string,unique_ptr~RobotHandler~~
        -metadata map~string,RobotMetadata~
        +getInstance() RobotRegistry static
        +registerRobot~Robot~(name) static
        +createRobotConfig(name, start, goal) any
        +createPlanner(name, config, factory) any
        +initializePlanner(name, planner)
        +executePlanning(name, planner, config) PlanningResult
        +isRobotRegistered(name) bool
        +getRegisteredRobots() vector~string~
        -RobotRegistry()
    }
    
    class RobotHandler {
        <<interface>>
        +createRobotConfig(start, goal) any*
        +createPlanner(config, factory) any*
        +initializePlanner(planner)*
        +executePlanning(planner, config) PlanningResult*
        +getMetadata() RobotMetadata*
        +validateConfigurationSize(start, goal) bool*
    }
    
    class TypedRobotHandler~Robot~ {
        +createRobotConfig(start, goal) any
        +createPlanner(config, factory) any
        +initializePlanner(planner)
        +executePlanning(planner, config) PlanningResult
        +getMetadata() RobotMetadata
        +validateConfigurationSize(start, goal) bool
        -castPlanner(any) VampOMPLPlanner~Robot~*
    }
    
    %% Factory System
    class PlannerFactory {
        <<Singleton + Registry>>
        -plannerCreators map~string,PlannerCreatorFunction~
        +getInstance() PlannerFactory static
        +createPlanner(name, si) PlannerPtr
        +registerPlanner(name, factory)
        +getAvailablePlannerNames() string
        -PlannerFactory()
    }
    
    %% VAMP Environment System
    class VectorizedEnvironment {
        <<SIMD-optimized>>
        +spheres vector~Sphere~
        +cuboids vector~Cuboid~
        +capsules vector~Capsule~
        +pointclouds vector~Pointcloud~
        +sort()
        +checkCollision(configurations) bool
    }
    
    %% Built-in Robot Types (examples)
    class VAMPPanda {
        <<Built-in Robot>>
        +dimension: size_t = 7
        +n_spheres: size_t = 10
        +resolution: size_t = 64
        +s_a: array~float,7~
        +s_m: array~float,7~
        +fkcc~rake~(env, config) bool static
        +scale_configuration(config) static
        +descale_configuration(config) static
        +name: string = "panda"
    }
    
    class VAMPUR5 {
        <<Built-in Robot>>
        +dimension: size_t = 6
        +n_spheres: size_t = 8
        +resolution: size_t = 32
        +s_a: array~float,6~
        +s_m: array~float,6~
        +fkcc~rake~(env, config) bool static
        +scale_configuration(config) static
        +descale_configuration(config) static
        +name: string = "ur5"
    }
    
    %% Benchmarking System
    class VampBenchmarkManager~Robot~ {
        <<Benchmarking Facade>>
        -planner unique_ptr~VampOMPLPlanner~Robot~~
        -robotName string
        +VampBenchmarkManager(robotConfig, envFactory)
        +initialize()
        +executeBenchmark(config) string
        +isInitialized() bool
        +getRobotConfiguration() RobotConfig~Robot~
        +getEnvironmentFactory() EnvironmentFactory
        -addPlannersToOMPLBenchmark(benchmark, config, si)
        -generateBenchmarkFileName(config) string
    }
    
    %% Core Relationships - OMPL Integration
    OMPLStateValidityChecker <|-- VampStateValidator
    OMPLMotionValidator <|-- VampMotionValidator
    
    VampOMPLPlanner --> OMPLPlanningContext : uses
    VampOMPLPlanner --> RobotConfig : configures
    VampOMPLPlanner --> EnvironmentFactory : creates_environment
    VampOMPLPlanner --> VectorizedEnvironment : optimizes
    
    OMPLPlanningContext --> OMPLSpaceInformation : manages
    OMPLPlanningContext --> OMPLProblemDefinition : manages
    OMPLPlanningContext --> VampStateValidator : creates
    OMPLPlanningContext --> VampMotionValidator : creates
    OMPLPlanningContext --> PlannerRegistry : uses
    
    PlannerRegistry --> OMPLPlanner : creates
    
    %% Configuration System Relationships
    RobotConfig <|-- RobotConfiguration
    EnvironmentFactory <|-- ConfigurableEnvironmentFactory
    
    %% Registry System Relationships
    RobotRegistry --> RobotHandler : manages
    RobotHandler <|-- TypedRobotHandler
    TypedRobotHandler --> VampOMPLPlanner : creates
    TypedRobotHandler --> RobotConfiguration : creates
    
    %% Environment System
    ConfigurableEnvironmentFactory --> VectorizedEnvironment : creates
    VampStateValidator --> VectorizedEnvironment : validates_against
    VampMotionValidator --> VectorizedEnvironment : validates_against
    
    %% Built-in Robot Registration
    VAMPPanda ..> RobotRegistry : auto_registered
    VAMPUR5 ..> RobotRegistry : auto_registered
    
    %% Benchmarking Relationships
    VampBenchmarkManager --> VampOMPLPlanner : composes
    VampBenchmarkManager --> OMPLSpaceInformation : uses
    
    %% Template Relationships
    VampOMPLPlanner : Robot
    OMPLPlanningContext : Robot
    VampStateValidator : Robot
    VampMotionValidator : Robot
    RobotConfig : Robot
    RobotConfiguration : Robot
    TypedRobotHandler : Robot
    VampBenchmarkManager : Robot
