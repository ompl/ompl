# API Overview {#api_overview}

\htmlonly
@OMPLSVG@
\endhtmlonly

The class ownership diagram above shows the relationship between the essential base classes in OMPL. For example, __SpaceInformation__ owns a __StateSpace__; __Planner__ does _not_ own __SpaceInformation__, although a __Planner__ does know about the __SpaceInformation__, and uses provided functionality. Users are encouraged to use the __SimpleSetup__ class (ompl::geometric::SimpleSetup or ompl::control::SimpleSetup). With this class, it is only necessary to instantiate a ompl::base::StateSpace object, a ompl::control::ControlSpace object (when planning with differential constraints, i.e., planning with controls), and a ompl::base::StateValidityChecker object. Many common state spaces have already been implemented as derived __StateSpace__ classes. See a list [here](spaces.html).

The ompl::base::StateValidityChecker is problem-specific, so no default implementation is available. See [this document](stateValidation.html) for more information on state validity checking. For more advanced definitions of goals, see [this document](goalRepresentation.html).

## Doxygen-generated documentation

- [Namespace List](namespaces.html)
- [Class List](annotated.html)

## Thread safety

All static, non-member or const member functions are thread safe. Calling member functions that are not const in multiple threads simultaneously is unsafe and locks should be used.

## Memory management

For all base classes __Class__, a __ClassPtr__ type is defined as well. __ClassPtr__ is in fact a [shared pointer](http://en.cppreference.com/w/cpp/memory/shared_ptr) for __Class__:

~~~{.cpp}
class Class;
using ClassPtr = std::shared_ptr<Class>;
~~~

The code above is generated by the OMPL_CLASS_FORWARD macro defined in ompl/util/ClassForward.h:

~~~{.cpp}
OMPL_CLASS_FORWARD(Class);
~~~

Often the user is required to operate with \b *Ptr variables, in order to ensure all memory is freed at the termination of the program without explicitly calling `delete`. For some classes internal to the library, a C-style pointer is maintained instead of the \b *Ptr variable to avoid cyclic dependencies (which prevent memory de-allocation).
