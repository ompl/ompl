/**
\mainpage

@section summary Summary 
    
   @b ompl (Open Motion Planning Library) consists of a set of
   sampling-based motion planning algorithms and nothing more. There
   is no environment specification, there is no collision detection or
   visualisation. There are only motion planners. The purpose of this
   library is to be extensible and freely available. It currently
   contains a set of kinematic sampling-based motion planners and some
   initial versions of planners that can account for differential
   constraints.

   The overall structure can be observed by looking at the @b base/
   directory. There are two main components: 
   - the space information
      - state validity checker
      - state distance evaluator
      - state sampler
      - start states
      - goal specification
   - the planner

   The base space information class (ompl::base::SpaceInformation)
   contains only basic definitions of states, paths and goals. It also
   has pointers to instances of classes used for distance evaluation,
   state validation and sampling. This class is not meant to be used
   directly. Specializations such as
   ompl::kinematic::SpaceInformationKinematic are intended for the
   user.

   <hr> 

   The code in this library is meant to be thread safe. All static,
   non-member or const member functions are thread safe. Calling
   member functions that are not const in multiple threads
   simultaneously is unsafe and locks should be used.
   
   <hr>

   @section avail_planners Available Planners
   
   @subsection kinematic_planners Planning under geometric constraints

   This set of planners only accounts for the geometric constraints of
   the system.  Infinite accelerations and velocities are assumed.


   - @ref kRRT "Rapidly-exploring Random Trees (RRT)"
   - @ref kLazyRRT "Lazy RRT (LazyRRT)"
   - @ref kRRTC "RRT Connect (RRTConnect)"
   - @ref kpRRT "Parallel Rapidly-exploring Random Trees (pRRT)"
   - @ref kSBL "Single-query Bi-directional Lazy collision checking planner (SBL)"
   - @ref kpSBL "Parallel Single-query Bi-directional Lazy collision checking planner (pSBL)"
   - @ref kEST "Expansive Space Trees (EST)"
   - @ref kKPIECE1 "Kinematic Planning by Interior-Exterior Cell Exploration (KPIECE)"
   - @ref kLBKPIECE1 "Lazy Bi-directional KPIECE (LBKPIECE)"	

   Other tools:

   - @ref HCIK "Inverse Kinematics with Hill Climbing"
   - @ref GAIK "Inverse Kinematics with Genetic Algorithms"
   - @ref IKPlanner "Inverse Kinematics Planner"

   @subsection kusage Usage

   @subsubsection plannerinstance Instantiating a planner

   In order to use a motion planner (ompl::kinematic::XXX, from @b
   ompl/kinematic/planners), an instance of a kinematic space
   information must be available. This instance is supplied to the
   planner's constructor.  After creation, a call to the planner's @b
   setup() method must be made and the planner instance is ready for
   use: the @b solve() method can be called repeatedly with different
   allowed time durations until a solution is found.

   @subsubsection spaceinfo Instantiating a space information class

   Creating an actual instance of a kinematic space information class
   (ompl::kinematic::SpaceInformationKinematic) is trivial as the
   constructor requires no parameters. However, this class needs to be
   configured before use:

     - a std::vector < ompl::base::StateComponent > must be supplied to
       the space information class by calling @b
       setStateComponents. This specification describes a bounding
       box for the state space. Random samples will only be generated
       within this box.

     - instances of ompl::base::State need to be supplied as starting
       states for the system (at least one), using @b addStartState.

     - an ompl::base::Goal specification must be set using @b
       setGoal. For simplicity, specifications of this class are
       available: ompl::base::GoalRegion, ompl::base::GoalState,
       ompl::kinematic::GoalRegionKinematic.

     - ompl::base::StateValidityChecker is an abstract class that
       provides functionality for determining whether a state is valid
       or not. This class is assumed to be thread safe. The user must
       provide an implementation of this class and supply it to the
       space information instance by calling @b
       setStateValidityChecker.
       
     - ompl::base::StateDistanceEvaluator is an abstract class that
       provides functionality for computing distances between
       functions. This class is assumed to be thread safe. The user
       can specify which implementation of this class is to be used by
       calling @b setStateDistanceEvaluator. If no distane evaluator
       is specified, the default
       ompl::base::L2SquareStateDistanceEvaluator is used (square of
       L2 norm).

     - ompl::base::StateSampler is an abstract class that provides
       functionality for sampling states. This class is NOT assumed to
       be thread safe because of issues of generating random samples
       in parallel, using the same seed. For this reason, state samplers are
       instantiated as needed. In order for proper instantiation to
       occur, the user should supply a boost::function that takes a
       const ompl::base::SpaceInformation as argument and returns an
       instance of the desired sampler (which inherits from
       ompl::base::StateSampler). This function can be supplied to the
       space information instance using @b
       setStateSamplerAllocator. If no state sampler allocator is
       specified, a default allocator that instantiates
       ompl::base::UniformStateSampler is assumed.

     - ompl::kinematic::StateInterpolatorKinematic is an abstract
       class that provides functionality for interpolating between
       states. This class is assumed to be thread safe. Users can set
       which instance of this class to use by calling @b
       setStateInterpolator. If no state interpolator is provided, a
       linear one is assumed
       (ompl::kinematic::LinearStateInterpolatorKinematic).


   Some of these parameters can als be set if the user provides a
   space information class that inherits from
   ompl::kinematic::SpaceInformationKinematic. This use is encouraged
   if it simplifies the code.

   Once the class is instantiated and all parameters have been set,
   the @b setup() function needs to be called and the instance is
   ready for use.

   @subsubsection kinstexample Example

   @code

   #include <ompl/kinematic/SpaceInformationKinematic.h>
   #include <ompl/kinematic/planners/rrt/RRT.h>
   #include <ompl/base/GoalState.h>

   #include <ompl/kinematic/PathSmootherKinematic.h>

   ...

   class myStateValidityChecker : public ompl::base::StateValidityChecker
   {
   public:
      myStateValidityChecker(const ompl::base::SpaceInformation *si) : ompl::base::StateValidityChecker(si)
      {
      }
      
      virtual bool operator()(const ompl::base::State *state) const
      {
            // provide implementation here
      }
   };

   ompl::base::StateSampler* myAllocStateSampler(const ompl::base::SpaceInformation *si)
   {
	return new ompl::base::UniformStateSampler(si);
   }

   ...

   ompl::kinematic::SpaceInformationKinematic *si = new ompl::kinematic::SpaceInformationKinematic();
   
   std::vector<ompl::base::StateComponent> stateSpec;
   // fill stateSpec
   si->setStateComponents(stateSpec);
   
   ompl::base::State *start = new ompl::base::State(stateSpec.size()); // the state needs to have the correct dimension
   // fill start state

   si->addStartState(state); // memory for state will not be freed unless we call clearStartStates()


   ompl::base::GoalState *gs = new ompl::base::GoalState(si);
   // fill goal

   si->setGoal(gs);

   myStateValidityChecker *svc = new myStateValidityChecker(si);
   si->setStateValidityChecker(svc);

   // this is only to show the API. The default is assumed anyway, we don't need to set it
   ompl::base::StateDistanceEvaluator *sde = new ompl::base::L2SquareStateDistanceEvaluator(si);
   si->setStateDistanceEvaluator(sde);

   // this is only to show the API. The default is assumed anyway, we don't need to set it
   si->setStateSamplerAllocator(boost::bind(myAllocStateSampler, _1));

   // this is only to show the API. The default is assumed anyway, we don't need to set it
   ompl::kinematic::StateInterpolatorKinematic *sik = new ompl::kinematic::LinearStateInterpolatorKinematic(si);
   si->setStateInterpolator(sik);


   si->setup();

   ompl::base::Planner *p = new ompl::kinematic::RRT(si);
   p->setup();
   p->solve(0.5);
   
   // the goal contains a pointer to an abstract path, but we know it is actually a kinematic one
   // since we used a kinematic planner
   ompl::kinematic::PathKinematic *solution = static_cast<ompl::kinematic::PathKinematic*>(si->getGoal()->getSolutionPath());
   

   // make the goal region forget about the solution it found; if
   // we don't, the memory associated to the solution path will be
   // deleted when the goal instance is deleted
   gs->forgetSolutionPath();

   // create an instance if a kinematic smoother 
   ompl::kinematic::PathSmootherKinematic *smoother = new ompl::kinematic::PathSmootherKinematic(si);
   smoother->smoothMax(solution); // the smoothing is done in place
   
   // output solution somehow 
   ...

   // clear memory for the solution path
   delete solution;

   // free memory for the smoother
   delete smoother;

   // frees start states; not done by default
   si->clearStartStates();

   // frees memory for the goal; not done by default
   // since forgetSolutionPath() was called, this does not free the solution path
   si->clearGoal();

   // delete state validity checker; space information does not take ownership of this
   delete svc;

   // delete state interpolator; space information does not take ownership of this
   delete sik;
   
   // delete space information; all memory is freed now
   delete si;

   @endcode

   @subsection dynamic_planners Planning under differential constraints

   This part of the library is not considered ready for use.
   
   - @ref dRRT "Rapidly-exploring Random Trees (RRT)"


*/
