#!/usr/bin/env python3
"""
VAMP-OMPL Solution Path Visualizer

This script provides visualization and animation of solution paths generated by the VAMP-OMPL demos.
It supports all robots (Panda, UR5, Fetch) and environments (Empty, Sphere Cage, Table Scene, Custom).

Usage:
    python visualize_solution.py solution_path_Panda_sphere_cage_BIT*.txt
    python visualize_solution.py --robot panda --environment sphere_cage --path my_path.txt
    python visualize_solution.py --robot panda --environment custom --obstacles "type=sphere,position_x=0.2,position_y=0.2,position_z=0.5,radius=0.1"
    python visualize_solution.py --interactive
"""

import argparse
import base64
import os
import sys
import time
import warnings
import numpy as np
import pybullet as p
import pybullet_data
from typing import List, Tuple, Dict, Optional
from pathlib import Path

# Suppress PyBullet warnings at module level
warnings.filterwarnings("ignore")
os.environ['PYBULLET_PRINTING'] = '0'

import logging
import contextlib
logging.getLogger('pybullet').setLevel(logging.CRITICAL)


class OutputSuppressor:
    """Enhanced suppressor for PyBullet C++ output"""
    
    def __init__(self):
        self.original_stdout = None
        self.original_stderr = None
        self.original_stdout_fd = None
        self.original_stderr_fd = None
        self.devnull_fd = None
        
    def __enter__(self):
        try:
            # Method 1: Python level redirection
            self.original_stdout = sys.stdout
            self.original_stderr = sys.stderr
            sys.stdout = open(os.devnull, 'w')
            sys.stderr = open(os.devnull, 'w')
            
            # Method 2: File descriptor level redirection
            self.original_stdout_fd = os.dup(1)
            self.original_stderr_fd = os.dup(2)
            self.devnull_fd = os.open(os.devnull, os.O_WRONLY)
            os.dup2(self.devnull_fd, 1)
            os.dup2(self.devnull_fd, 2)
            
            # Method 3: Force flush to ensure redirection takes effect
            if hasattr(sys.stdout, 'flush'):
                sys.stdout.flush()
            if hasattr(sys.stderr, 'flush'):
                sys.stderr.flush()
                
        except Exception as e:
            # Fallback: at least try Python level
            sys.stdout = open(os.devnull, 'w')
            sys.stderr = open(os.devnull, 'w')
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        try:
            # Restore file descriptors first
            if self.original_stdout_fd is not None:
                os.dup2(self.original_stdout_fd, 1)
                os.close(self.original_stdout_fd)
            if self.original_stderr_fd is not None:
                os.dup2(self.original_stderr_fd, 2)
                os.close(self.original_stderr_fd)
            if self.devnull_fd is not None:
                os.close(self.devnull_fd)
                
            # Then restore Python level
            if self.original_stdout is not None:
                sys.stdout.close() if hasattr(sys.stdout, 'close') else None
                sys.stdout = self.original_stdout
            if self.original_stderr is not None:
                sys.stderr.close() if hasattr(sys.stderr, 'close') else None
                sys.stderr = self.original_stderr
                
        except Exception:
            # Emergency restore
            sys.stdout = sys.__stdout__
            sys.stderr = sys.__stderr__


class URDFPathResolver:
    """Utility class to find URDF files across different robots"""
    
    ROBOT_PATHS = {
        'panda': 'panda/panda.urdf',
        'ur5': 'ur5/ur5.urdf', 
        'fetch': 'fetch/fetch.urdf'
    }
    
    @classmethod
    def find_urdf(cls, robot_name: str, custom_path: Optional[str] = None) -> str:
        """Find URDF file for given robot"""
        if custom_path and os.path.exists(custom_path):
            return custom_path
            
        robot_path = cls.ROBOT_PATHS.get(robot_name.lower())
        if not robot_path:
            raise ValueError(f"Unknown robot: {robot_name}")
            
        search_dirs = [
            "external/vamp/resources",
            "../external/vamp/resources", 
            "../../external/vamp/resources"
        ]
        
        for search_dir in search_dirs:
            full_path = os.path.join(search_dir, robot_path)
            if os.path.exists(full_path):
                return full_path
                
        raise FileNotFoundError(f"Could not find URDF file for {robot_name} at {robot_path}")


class RobotConfig:
    """Robot configuration with joint limits and default poses"""
    
    ROBOT_SPECS = {
        'panda': {
            'joint_count': 7,
            'limits': [(-2.8973, 2.8973), (-1.7628, 1.7628), (-2.8973, 2.8973),
                      (-3.0718, -0.0698), (-2.8973, 2.8973), (-0.0175, 3.7525),
                      (-2.8973, 2.8973)],
            'start': [0.0, -0.785, 0.0, -2.356, 0.0, 1.571, 0.785],
            'goal': [2.35, 1.0, 0.0, -0.8, 0.0, 2.5, 0.785]
        },
        'ur5': {
            'joint_count': 6,
            'limits': [(-3.14159, 3.14159)] * 6,
            'start': [0.0, -1.57, 1.57, -1.57, -1.57, 0.0],
            'goal': [1.57, -0.5, 0.5, -1.0, -1.57, 1.57]
        },
        'fetch': {
            'joint_count': 7,
            'limits': [(-1.6056, 1.6056), (-1.221, 1.518), (-3.14159, 3.14159),
                      (-2.251, 2.251), (-3.14159, 3.14159), (-2.16, 2.16),
                      (-3.14159, 3.14159)],
            'start': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            'goal': [1.32, 1.40, -0.2, 1.72, 0.0, 1.66, 0.0]
        }
    }
    
    # Robot name aliases for robust detection
    ROBOT_ALIASES = {
        'franka': 'panda',
        'franka emika': 'panda',
        'franka panda': 'panda',
        'universal robots': 'ur5',
        'fetch robotics': 'fetch'
    }
    
    def __init__(self, robot_name: str, urdf_path: Optional[str] = None):
        # Normalize robot name
        self.name = robot_name.lower()
        
        # Check aliases
        if self.name in self.ROBOT_ALIASES:
            self.name = self.ROBOT_ALIASES[self.name]
        
        if self.name not in self.ROBOT_SPECS:
            raise ValueError(f"Unsupported robot: {robot_name}. Supported: panda, ur5, fetch")
            
        self.urdf_path = URDFPathResolver.find_urdf(self.name, urdf_path)
        self.spec = self.ROBOT_SPECS[self.name]
        self.joint_indices = list(range(self.spec['joint_count']))
        
    @property
    def joint_limits(self) -> List[Tuple[float, float]]:
        return self.spec['limits']
        
    @property
    def default_start(self) -> np.ndarray:
        return np.array(self.spec['start'])
        
    @property
    def default_goal(self) -> np.ndarray:
        return np.array(self.spec['goal'])


class EnvironmentFactory:
    """Factory for creating different environments"""
    
    @staticmethod
    def create_environment(env_name: str, obstacles_data: str = None) -> List[int]:
        """Create environment and return obstacle IDs"""
        env_name = env_name.lower().replace('_', '')
        
        if env_name in ['empty', 'emptyenvironment']:
            return []
        elif env_name in ['spherecage', 'sphere']:
            return EnvironmentFactory._create_sphere_cage()
        elif env_name in ['tablescene', 'table']:
            return EnvironmentFactory._create_table_scene()
        elif env_name in ['custom']:
            if obstacles_data:
                return EnvironmentFactory._create_custom_obstacles(obstacles_data)
            else:
                print("‚ö†Ô∏è Custom environment but no obstacles data provided")
                return []
        else:
            raise ValueError(f"Unknown environment: {env_name}")
    
    @staticmethod 
    def _create_sphere_cage(radius: float = 0.15) -> List[int]:
        """Create sphere cage environment"""
        positions = [
            [0.55, 0, 0.25], [0.35, 0.35, 0.25], [0, 0.55, 0.25],
            [-0.55, 0, 0.25], [-0.35, -0.35, 0.25], [0, -0.55, 0.25],
            [0.35, -0.35, 0.25], [0.35, 0.35, 0.8], [0, 0.55, 0.8],
            [-0.35, 0.35, 0.8], [-0.55, 0, 0.8], [-0.35, -0.35, 0.8],
            [0, -0.55, 0.8], [0.35, -0.35, 0.8]
        ]
        
        obstacle_ids = []
        for pos in positions:
            collision_shape = p.createCollisionShape(p.GEOM_SPHERE, radius=radius)
            visual_shape = p.createVisualShape(p.GEOM_SPHERE, radius=radius,
                                             rgbaColor=[0.8, 0.1, 0.1, 0.7])
            obstacle_id = p.createMultiBody(baseMass=0, 
                                          baseCollisionShapeIndex=collision_shape,
                                          baseVisualShapeIndex=visual_shape,
                                          basePosition=pos)
            obstacle_ids.append(obstacle_id)
        return obstacle_ids
    
    @staticmethod 
    def _create_table_scene() -> List[int]:
        """Create table scene environment"""
        boxes = [
            # (min_corner, max_corner, color)
            ([-0.5, -0.5, 0.8], [0.5, 0.5, 0.82], [0.6, 0.4, 0.2, 1.0]),  # Table
            ([0.2, 0.1, 0.82], [0.3, 0.2, 0.92], [0.1, 0.8, 0.1, 0.8]),   # Obstacle 1
            ([-0.2, 0.2, 0.82], [-0.1, 0.3, 0.92], [0.1, 0.1, 0.8, 0.8]), # Obstacle 2
            ([0.0, -0.2, 0.82], [0.1, -0.1, 0.92], [0.8, 0.8, 0.1, 0.8])  # Obstacle 3
        ]
        
        obstacle_ids = []
        for min_corner, max_corner, color in boxes:
            center = [0.5 * (min_corner[i] + max_corner[i]) for i in range(3)]
            extents = [0.5 * abs(max_corner[i] - min_corner[i]) for i in range(3)]
            
            collision_shape = p.createCollisionShape(p.GEOM_BOX, halfExtents=extents)
            visual_shape = p.createVisualShape(p.GEOM_BOX, halfExtents=extents, 
                                             rgbaColor=color)
            obstacle_id = p.createMultiBody(baseMass=0,
                                          baseCollisionShapeIndex=collision_shape,
                                          baseVisualShapeIndex=visual_shape, 
                                          basePosition=center)
            obstacle_ids.append(obstacle_id)
        return obstacle_ids
    
    @staticmethod
    def _create_custom_obstacles(obstacles_data: str) -> List[int]:
        """Create custom obstacles from serialized data"""
        print(f"üîç Creating custom obstacles from data: {obstacles_data}")
        obstacle_ids = []
        
        if not obstacles_data:
            return obstacle_ids
            
        # Parse obstacles data: type=sphere,position_x=0.1,position_y=0.2,position_z=0.3,radius=0.1;...
        obstacles = obstacles_data.split(';')
        
        for obstacle_str in obstacles:
            if not obstacle_str.strip():
                continue
                
            # Parse key=value pairs
            props = {}
            for prop in obstacle_str.split(','):
                if '=' in prop:
                    key, value = prop.split('=', 1)
                    props[key.strip()] = value.strip()
            
            if 'type' not in props:
                print(f"‚ö†Ô∏è Skipping obstacle without type: {props}")
                continue
                
            obstacle_type = props['type']
            
            try:
                if obstacle_type == 'sphere':
                    obstacle_id = EnvironmentFactory._create_sphere_obstacle(props)
                elif obstacle_type == 'cuboid':
                    obstacle_id = EnvironmentFactory._create_cuboid_obstacle(props)
                elif obstacle_type == 'capsule':
                    obstacle_id = EnvironmentFactory._create_capsule_obstacle(props)
                else:
                    print(f"‚ö†Ô∏è Unknown obstacle type: {obstacle_type}")
                    continue
                    
                if obstacle_id is not None:
                    obstacle_ids.append(obstacle_id)
                    print(f"‚úì Created {obstacle_type} obstacle")
                    
            except Exception as e:
                print(f"‚ùå Error creating {obstacle_type} obstacle: {e}")
                continue
        
        print(f"‚úì Created {len(obstacle_ids)} custom obstacles")
        return obstacle_ids
    
    @staticmethod
    def _create_sphere_obstacle(props: dict) -> int:
        """Create a sphere obstacle from properties"""
        position = [
            float(props.get('position_x', 0)),
            float(props.get('position_y', 0)),
            float(props.get('position_z', 0))
        ]
        radius = float(props.get('radius', 0.1))
        
        collision_shape = p.createCollisionShape(p.GEOM_SPHERE, radius=radius)
        visual_shape = p.createVisualShape(p.GEOM_SPHERE, radius=radius,
                                         rgbaColor=[0.8, 0.2, 0.2, 0.8])
        obstacle_id = p.createMultiBody(baseMass=0,
                                      baseCollisionShapeIndex=collision_shape,
                                      baseVisualShapeIndex=visual_shape,
                                      basePosition=position)
        return obstacle_id
    
    @staticmethod
    def _create_cuboid_obstacle(props: dict) -> int:
        """Create a cuboid obstacle from properties"""
        position = [
            float(props.get('position_x', 0)),
            float(props.get('position_y', 0)),
            float(props.get('position_z', 0))
        ]
        half_extents = [
            float(props.get('half_extents_x', 0.05)),
            float(props.get('half_extents_y', 0.05)),
            float(props.get('half_extents_z', 0.05))
        ]
        orientation = [
            float(props.get('orientation_x', 0)),
            float(props.get('orientation_y', 0)),
            float(props.get('orientation_z', 0))
        ]
        
        # Convert Euler angles to quaternion
        quaternion = p.getQuaternionFromEuler(orientation)
        
        collision_shape = p.createCollisionShape(p.GEOM_BOX, halfExtents=half_extents)
        visual_shape = p.createVisualShape(p.GEOM_BOX, halfExtents=half_extents,
                                         rgbaColor=[0.2, 0.8, 0.2, 0.8])
        obstacle_id = p.createMultiBody(baseMass=0,
                                      baseCollisionShapeIndex=collision_shape,
                                      baseVisualShapeIndex=visual_shape,
                                      basePosition=position,
                                      baseOrientation=quaternion)
        return obstacle_id
    
    @staticmethod
    def _create_capsule_obstacle(props: dict) -> int:
        """Create a capsule obstacle from properties"""
        position = [
            float(props.get('position_x', 0)),
            float(props.get('position_y', 0)),
            float(props.get('position_z', 0))
        ]
        radius = float(props.get('radius', 0.05))
        length = float(props.get('length', 0.2))
        orientation = [
            float(props.get('orientation_x', 0)),
            float(props.get('orientation_y', 0)),
            float(props.get('orientation_z', 0))
        ]
        
        # Convert Euler angles to quaternion
        quaternion = p.getQuaternionFromEuler(orientation)
        
        collision_shape = p.createCollisionShape(p.GEOM_CAPSULE, radius=radius, height=length)
        visual_shape = p.createVisualShape(p.GEOM_CAPSULE, radius=radius, length=length,
                                         rgbaColor=[0.2, 0.2, 0.8, 0.8])
        obstacle_id = p.createMultiBody(baseMass=0,
                                      baseCollisionShapeIndex=collision_shape,
                                      baseVisualShapeIndex=visual_shape,
                                      basePosition=position,
                                      baseOrientation=quaternion)
        return obstacle_id


class PathFileReader:
    """Reads solution path files"""
    
    @staticmethod
    def read_path(filepath: str) -> Tuple[np.ndarray, Dict[str, str]]:
        """Read solution path file and return waypoints and metadata"""
        if not os.path.exists(filepath):
            raise FileNotFoundError(f"Path file not found: {filepath}")
            
        waypoints = []
        metadata = {}
        
        with open(filepath, 'r') as f:
            for line in f:
                line = line.strip()
                if line.startswith('#'):
                    # Parse metadata from comments  
                    if 'Solution Path for' in line:
                        # Format: "# Solution Path for [ROBOT] in [ENV] environment using [PLANNER] planner"
                        try:
                            # Extract robot name (between "for " and " in ")
                            start_idx = line.find('for ') + 4
                            end_idx = line.find(' in ', start_idx)
                            if start_idx > 3 and end_idx > start_idx:
                                robot_full = line[start_idx:end_idx]
                                metadata['robot'] = robot_full.lower()
                            
                            # Extract environment name (between " in " and " environment")
                            start_idx = line.find(' in ') + 4
                            end_idx = line.find(' environment', start_idx)
                            if start_idx > 3 and end_idx > start_idx:
                                env_full = line[start_idx:end_idx]
                                metadata['environment'] = env_full.lower()
                                
                            # Extract planner name (between "using " and " planner")
                            start_idx = line.find('using ') + 6
                            end_idx = line.find(' planner', start_idx)
                            if start_idx > 5 and end_idx > start_idx:
                                planner_name = line[start_idx:end_idx]
                                metadata['planner'] = planner_name
                        except:
                            pass  # Fallback to filename parsing
                elif line and not line.startswith('#'):
                    # Parse waypoint data
                    try:
                        joints = [float(x) for x in line.split('\t')]
                        waypoints.append(joints)
                    except ValueError:
                        continue
                        
        if not waypoints:
            raise ValueError(f"No valid waypoints found in {filepath}")
            
        return np.array(waypoints), metadata


def parse_filename(filepath: str) -> Tuple[str, str, str]:
    """Parse robot, environment, and planner from filename"""
    filename = os.path.basename(filepath)
    if not filename.startswith("solution_path_"):
        raise ValueError("Invalid filename format")
        
    # Remove prefix and suffix
    base = filename[14:-4]  
    
    # Robot name mappings (handle full names with spaces)
    robot_mappings = {
        'franka emika panda': 'panda',
        'panda': 'panda',
        'universal robots ur5': 'ur5', 
        'ur5': 'ur5',
        'fetch robotics fetch': 'fetch',
        'fetch': 'fetch'
    }
    
    # Environment name mappings  
    env_mappings = {
        'sphere cage': 'sphere_cage',
        'table scene': 'table_scene',
        'empty environment': 'empty',
        'empty': 'empty'
    }
    
    # Find robot by looking for known robot patterns
    robot_name = None
    env_name = None
    planner_name = None
    
    base_lower = base.lower()
    
    # Find robot name
    for full_robot, simple_robot in robot_mappings.items():
        if base_lower.startswith(full_robot.lower()):
            robot_name = simple_robot
            remainder = base[len(full_robot):].lstrip('_')
            break
    
    if not robot_name:
        raise ValueError(f"Could not identify robot in filename: {filename}")
    
    # Find environment name in remainder
    remainder_lower = remainder.lower()
    for full_env, simple_env in env_mappings.items():
        if remainder_lower.startswith(full_env.lower()):
            env_name = simple_env
            planner_name = remainder[len(full_env):].lstrip('_')
            break
    
    if not env_name:
        raise ValueError(f"Could not identify environment in filename: {filename}")
        
    return robot_name, env_name, planner_name


def find_solution_files() -> List[str]:
    """Find solution path files in common locations"""
    search_dirs = [".", "demos/Vamp", "../demos/Vamp", "../../demos/Vamp"]
    files = []
    
    for search_dir in search_dirs:
        if os.path.exists(search_dir):
            try:
                dir_files = [f for f in os.listdir(search_dir) 
                           if f.startswith("solution_path_") and f.endswith(".txt")]
                files.extend([os.path.join(search_dir, f) for f in dir_files 
                            if os.path.isfile(os.path.join(search_dir, f))])
            except PermissionError:
                continue
                
    return list(set(files))  # Remove duplicates


class VampVisualizer:
    """Main visualization system for VAMP-OMPL solutions"""
    
    def __init__(self, gui: bool = True, verbose: bool = False):
        self.gui = gui
        self.verbose = verbose
        self.physics_client = None
        self.robot_config = None
        self.robot_id = None
        self.obstacle_ids = []
        self.trajectory_line_ids = []
        self.start_marker_id = None
        self.goal_marker_id = None
        
    def initialize(self):
        """Initialize PyBullet simulation"""
        if self.physics_client is not None:
            return
        
        # Connect directly to the desired mode with maximum suppression
        with OutputSuppressor():
            if self.gui:
                # Connect to GUI with all suppression options
                options = "--disable-urdf-loading-prints --disable_file_caching"
                self.physics_client = p.connect(p.GUI, options=options)
                p.configureDebugVisualizer(p.COV_ENABLE_GUI, 1)
            else:
                self.physics_client = p.connect(p.DIRECT)
                
            p.configureDebugVisualizer(p.COV_ENABLE_TINY_RENDERER, 0)
            p.setAdditionalSearchPath(pybullet_data.getDataPath())
            p.setGravity(0, 0, -9.81)
            p.loadURDF("plane.urdf")
            
            # Set camera position within suppression context
            if self.gui:
                p.resetDebugVisualizerCamera(
                    cameraDistance=2.0, cameraYaw=45, cameraPitch=-30,
                    cameraTargetPosition=[0, 0, 0.5]
                )
                
            # Force GUI initialization by running a simulation step
            # This ensures all GUI initialization happens now and is suppressed
            if self.gui:
                p.stepSimulation()
                # Also trigger any other potential GUI operations
                p.addUserDebugText("", [0,0,0])  # Force text rendering system init
                p.removeAllUserDebugItems()  # Clean up
        
    def load_robot(self, robot_config: RobotConfig):
        """Load robot URDF"""
        self.robot_config = robot_config
        
        # Change to URDF directory for relative paths
        original_cwd = os.getcwd()
        urdf_dir = os.path.dirname(os.path.abspath(robot_config.urdf_path))
        os.chdir(urdf_dir)
        
        # Create minimal texture files in all locations PyBullet might check
        texture_locations = [
            "colors.png",
            "meshes/visual/colors.png", 
            "visual/colors.png",
            "./data/colors.png",
            "../data/colors.png"
        ]
        created_files = []
        
        # Create minimal valid PNG data (1x1 white pixel)
        png_data = base64.b64decode('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==')
        
        for tex_path in texture_locations:
            if not os.path.exists(tex_path):
                try:
                    # Create directory if needed
                    tex_dir = os.path.dirname(tex_path)
                    if tex_dir and not os.path.exists(tex_dir):
                        os.makedirs(tex_dir, exist_ok=True)
                    
                    with open(tex_path, "wb") as f:
                        f.write(png_data)
                    created_files.append(tex_path)
                except:
                    pass
        
        try:
            # Load URDF with flags to minimize output
            load_flags = p.URDF_USE_INERTIA_FROM_FILE | p.URDF_MERGE_FIXED_LINKS
            
            if self.verbose:
                self.robot_id = p.loadURDF(
                    os.path.basename(robot_config.urdf_path),
                    basePosition=[0, 0, 0], useFixedBase=True,
                    flags=load_flags
                )
            else:
                # Use multiple suppression techniques for maximum effectiveness
                with OutputSuppressor():
                    # Temporarily disable PyBullet's internal debug printing
                    original_debug = p.isNumpyEnabled()
                    try:
                        self.robot_id = p.loadURDF(
                            os.path.basename(robot_config.urdf_path),
                            basePosition=[0, 0, 0], useFixedBase=True,
                            flags=load_flags
                        )
                    finally:
                        pass
        finally:
            # Clean up all created texture files and empty directories
            for tex_path in created_files:
                try:
                    if os.path.exists(tex_path):
                        os.remove(tex_path)
                    
                    # Remove empty directories we may have created
                    tex_dir = os.path.dirname(tex_path)
                    if tex_dir and os.path.exists(tex_dir):
                        try:
                            if not os.listdir(tex_dir):  # Directory is empty
                                os.rmdir(tex_dir)
                                # Also try to remove parent if it's empty
                                parent_dir = os.path.dirname(tex_dir)
                                if parent_dir and os.path.exists(parent_dir) and not os.listdir(parent_dir):
                                    os.rmdir(parent_dir)
                        except:
                            pass
                except:
                    pass
            os.chdir(original_cwd)
            
        print(f"‚úì Loaded {robot_config.name} robot")
        
    def create_environment(self, env_name: str, obstacles_data: str = None):
        """Create environment obstacles"""
        if self.verbose:
            self.obstacle_ids = EnvironmentFactory.create_environment(env_name, obstacles_data)
        else:
            with OutputSuppressor():
                self.obstacle_ids = EnvironmentFactory.create_environment(env_name, obstacles_data)
                
        env_display = env_name.replace('_', ' ').title()
        print(f"‚úì Created {env_display} environment with {len(self.obstacle_ids)} obstacles")
        
    def set_joint_configuration(self, joint_values: np.ndarray):
        """Set robot joint positions"""
        if self.robot_id is None:
            raise RuntimeError("Robot not loaded")
            
        for i, joint_idx in enumerate(self.robot_config.joint_indices):
            p.resetJointState(self.robot_id, joint_idx, joint_values[i])
            
    def get_end_effector_position(self) -> np.ndarray:
        """Get end-effector position"""
        if self.robot_id is None:
            return np.array([0, 0, 0])
            
        # Use last joint as end-effector
        ee_link = max(self.robot_config.joint_indices)
        link_state = p.getLinkState(self.robot_id, ee_link)
        return np.array(link_state[0])
        
    def create_markers(self, start_config: np.ndarray, goal_config: np.ndarray):
        """Create start and goal position markers"""
        # Always suppress marker creation to avoid triggering GUI initialization
        with OutputSuppressor():
            # Get end-effector positions
            self.set_joint_configuration(start_config)
            start_pos = self.get_end_effector_position()
            
            self.set_joint_configuration(goal_config)
            goal_pos = self.get_end_effector_position()
            
            # Create visual markers
            start_visual = p.createVisualShape(p.GEOM_SPHERE, radius=0.04, 
                                             rgbaColor=[0.0, 1.0, 0.0, 0.8])
            goal_visual = p.createVisualShape(p.GEOM_SPHERE, radius=0.04,
                                            rgbaColor=[1.0, 0.0, 0.0, 0.8])
            
            self.start_marker_id = p.createMultiBody(baseMass=0, baseVisualShapeIndex=start_visual,
                                                   basePosition=start_pos)
            self.goal_marker_id = p.createMultiBody(baseMass=0, baseVisualShapeIndex=goal_visual,
                                                  basePosition=goal_pos)
            
            # Reset to start
            self.set_joint_configuration(start_config)
        
        print(f"‚úì Start marker: [{start_pos[0]:.3f}, {start_pos[1]:.3f}, {start_pos[2]:.3f}]")
        print(f"‚úì Goal marker: [{goal_pos[0]:.3f}, {goal_pos[1]:.3f}, {goal_pos[2]:.3f}]")
        
    def animate_path(self, waypoints: np.ndarray, duration: float = 10.0, 
                    loop: bool = False, draw_trajectory: bool = True):
        """Animate robot motion along path"""
        if waypoints.shape[0] < 2:
            print("Need at least 2 waypoints for animation")
            return
            
        self.create_markers(waypoints[0], waypoints[-1])
        
        print(f"üé¨ Animating {waypoints.shape[0]} waypoints over {duration:.1f}s")
        
        dt = 1.0 / 240.0
        total_steps = int(duration / dt)
        
        def run_animation():
            prev_ee_pos = None
            
            for step in range(total_steps):
                # Interpolate between waypoints
                progress = step / (total_steps - 1)
                waypoint_float = progress * (waypoints.shape[0] - 1)
                waypoint_idx = min(int(waypoint_float), waypoints.shape[0] - 2)
                alpha = waypoint_float - waypoint_idx
                
                # Linear interpolation
                current_config = ((1 - alpha) * waypoints[waypoint_idx] + 
                                alpha * waypoints[waypoint_idx + 1])
                
                self.set_joint_configuration(current_config)
                
                # Draw trajectory
                if draw_trajectory:
                    ee_pos = self.get_end_effector_position()
                    if prev_ee_pos is not None:
                        distance = np.linalg.norm(ee_pos - prev_ee_pos)
                        if distance < 0.2:  # Avoid large jumps
                            if self.verbose:
                                line_id = p.addUserDebugLine(
                                    prev_ee_pos, ee_pos, lineColorRGB=[0.0, 0.5, 1.0], 
                                    lineWidth=3.0
                                )
                            else:
                                with OutputSuppressor():
                                    line_id = p.addUserDebugLine(
                                        prev_ee_pos, ee_pos, lineColorRGB=[0.0, 0.5, 1.0], 
                                        lineWidth=3.0
                                    )
                            self.trajectory_line_ids.append(line_id)
                    prev_ee_pos = ee_pos.copy()
                
                if self.verbose:
                    p.stepSimulation()
                else:
                    with OutputSuppressor():
                        p.stepSimulation()
                time.sleep(dt)
        
        try:
            if loop:
                print("üîÑ Looping animation (Ctrl+C to stop)")
                while True:
                    self._clear_trajectory()
                    run_animation()
            else:
                run_animation()
                if draw_trajectory:
                    print(f"‚ú® Drew {len(self.trajectory_line_ids)} trajectory segments")
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Animation stopped")
            
    def _clear_trajectory(self):
        """Clear trajectory lines"""
        for line_id in self.trajectory_line_ids:
            try:
                p.removeUserDebugItem(line_id)
            except:
                pass
        self.trajectory_line_ids.clear()
        
    def cleanup(self):
        """Clean up PyBullet resources"""
        if self.physics_client is not None:
            self._clear_trajectory()
            p.disconnect(self.physics_client)


def interactive_mode() -> Optional[str]:
    """Interactive mode to select solution files"""
    files = find_solution_files()
    if not files:
        print("‚ùå No solution path files found!")
        print("Run a C++ demo first with path writing enabled.")
        return None
        
    print(f"\nüìÅ Found {len(files)} solution path files:")
    for i, path_file in enumerate(files):
        try:
            robot, env, planner = parse_filename(path_file)
            print(f"  {i+1}. {robot.title()} in {env.replace('_', ' ').title()} using {planner}")
        except:
            print(f"  {i+1}. {os.path.basename(path_file)}")
            
    try:
        choice = int(input(f"\nChoose a file (1-{len(files)}): ")) - 1
        return files[choice]
    except (ValueError, IndexError):
        print("‚ùå Invalid choice")
        return None


def main():
    """Main function with simplified argument handling"""
    parser = argparse.ArgumentParser(
        description="Visualize VAMP-OMPL solution paths using PyBullet",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python visualize_solution.py solution_path_Panda_sphere_cage_BIT*.txt
  python visualize_solution.py --robot panda --environment sphere_cage my_path.txt
  python visualize_solution.py --interactive
        """
    )
    
    parser.add_argument("path_file", nargs='?', help="Solution path file to visualize")
    parser.add_argument("--robot", choices=["panda", "ur5", "fetch"], help="Robot type")
    parser.add_argument("--environment", choices=["empty", "sphere_cage", "table_scene", "custom"], help="Environment type")
    parser.add_argument("--urdf", help="Custom URDF path for robot")
    parser.add_argument("--duration", type=float, default=10.0, help="Animation duration in seconds")
    parser.add_argument("--loop", action="store_true", help="Loop animation continuously")
    parser.add_argument("--no-trajectory", action="store_true", help="Don't draw trajectory lines")
    parser.add_argument("--no-gui", action="store_true", help="Run without GUI")
    parser.add_argument("--interactive", action="store_true", help="Interactive mode")
    parser.add_argument("--verbose", action="store_true", help="Show PyBullet warnings and debug output")
    parser.add_argument("--obstacles", help="Custom obstacles data in format: type=sphere,position_x=0.1,position_y=0.2,position_z=0.3,radius=0.1;...")
    
    args = parser.parse_args()
    
    # Interactive mode
    if args.interactive:
        print("üéØ VAMP-OMPL Solution Path Visualizer")
        print("=====================================")
        args.path_file = interactive_mode()
        if not args.path_file:
            return
    
    # Check if path file is specified
    if not args.path_file:
        parser.print_help()
        return
        
    if not os.path.exists(args.path_file):
        print(f"‚ùå Path file not found: {args.path_file}")
        return
    
    try:
        # Read solution path
        print(f"üìñ Reading solution path from: {args.path_file}")
        waypoints, metadata = PathFileReader.read_path(args.path_file)
        print(f"‚úì Loaded {waypoints.shape[0]} waypoints with {waypoints.shape[1]} joints")
        
        # Determine robot and environment
        if args.robot and args.environment:
            robot_name = args.robot
            env_name = args.environment
        else:
            # Try to parse from metadata first
            robot_full = metadata.get('robot', '').lower()
            env_full = metadata.get('environment', '').lower()
            
            # Map full names to simple names
            robot_mappings = {
                'franka emika panda': 'panda',
                'universal robots ur5': 'ur5',
                'fetch robotics fetch': 'fetch'
            }
            
            env_mappings = {
                'sphere cage': 'sphere_cage',
                'table scene': 'table_scene', 
                'empty environment': 'empty'
            }
            
            robot_name = robot_mappings.get(robot_full)
            env_name = env_mappings.get(env_full)
            
            # Fallback to filename parsing if metadata parsing failed
            if not robot_name or not env_name:
                try:
                    robot_name, env_name, _ = parse_filename(args.path_file)
                except ValueError as e:
                    print(f"‚ùå Could not determine robot/environment: {e}")
                    print("Please specify --robot and --environment")
                    return
            
            # Display detected configuration
            robot_display = robot_full.title() if robot_full else robot_name.title()
            env_display = env_full.title() if env_full else env_name.replace('_', ' ').title()
            print(f"ü§ñ Detected: {robot_display} in {env_display}")
        
        # Create robot configuration
        robot_config = RobotConfig(robot_name, args.urdf)
        
        # Initialize visualization system
        visualizer = VampVisualizer(gui=not args.no_gui, verbose=args.verbose)
        visualizer.initialize()
        visualizer.load_robot(robot_config)
        visualizer.create_environment(env_name, args.obstacles)
        
        # Set initial configuration and start animation
        visualizer.set_joint_configuration(waypoints[0])
        
        print(f"\nüé¨ Press Enter to start animation (duration: {args.duration}s, loop: {args.loop})")
        print("Features: Start/Goal markers ‚úì, Trajectory drawing ‚úì")
        input()
        
        # Animate the path
        visualizer.animate_path(waypoints, duration=args.duration, 
                              loop=args.loop, draw_trajectory=not args.no_trajectory)
        
        if not args.loop:
            print("\n‚ú® Animation complete! Close the PyBullet window or press Ctrl+C to exit...")
            try:
                while True:
                    time.sleep(0.1)
            except KeyboardInterrupt:
                print("\nüëã Exiting...")
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
    finally:
        if 'visualizer' in locals():
            visualizer.cleanup()


if __name__ == "__main__":
    main() 